import numpy as np
from mpi4py import MPI
from dolfinx import mesh, fem, io
from dolfinx.fem.petsc import LinearProblem
import ufl

# --- 1. DEFINE THE DOMAIN ---
domain = mesh.create_unit_square(MPI.COMM_WORLD, 32, 32, mesh.CellType.quadrilateral)

# MATH SPACE: Degree 2 (Crucial for 100% accuracy calculation)
V = fem.functionspace(domain, ("Lagrange", 2))

# PLOT SPACE: Degree 1 (Crucial for saving to file without crashing)
V_plot = fem.functionspace(domain, ("Lagrange", 1))

# --- 2. PARAMETERS ---
t = 0
T_final = 1.0
num_steps = 20
dt = T_final / num_steps
rho = 1.0; c = 1.0; k = 0.1 

# --- 3. EXACT SOLUTION ---
class ExactSolution:
    def __init__(self, t):
        self.t = t
    def __call__(self, x):
        return 1 + x[0]**2 + x[1]**2 + self.t

exact_sol = ExactSolution(t)
u_exact = fem.Function(V)
u_exact.interpolate(exact_sol)

# --- 4. BOUNDARY CONDITIONS ---
tdim = domain.topology.dim
fdim = tdim - 1
domain.topology.create_connectivity(fdim, tdim)
boundary_facets = mesh.exterior_facet_indices(domain.topology)
boundary_dofs = fem.locate_dofs_topological(V, fdim, boundary_facets)
bc = fem.dirichletbc(u_exact, boundary_dofs)

# --- 5. INITIAL CONDITION & SOURCE ---
T_n = fem.Function(V)
exact_sol.t = 0
T_n.interpolate(exact_sol)

# Source term derived from: rho*c*dT/dt - k*div(grad(T)) = f
f_val = (rho * c * 1.0) - (k * 4.0)
f = fem.Constant(domain, f_val)

# --- 6. VARIATIONAL PROBLEM (FIXED HERE) ---
u, v = ufl.TrialFunction(V), ufl.TestFunction(V)
F = rho * c * (u - T_n) / dt * v * ufl.dx \
    + k * ufl.dot(ufl.grad(u), ufl.grad(v)) * ufl.dx \
    - f * v * ufl.dx

# FIX: Added 'petsc_options_prefix' which is required in your version
problem = LinearProblem(ufl.lhs(F), ufl.rhs(F), bcs=[bc], 
                        petsc_options={"ksp_type": "preonly", "pc_type": "lu"},
                        petsc_options_prefix="ksp_solve")

# --- 7. VISUALIZATION SETUP ---
# We create placeholders in V_plot (Degree 1) for the XDMF file
T_plot = fem.Function(V_plot)
T_plot.name = "Numerical"

Ex_plot = fem.Function(V_plot)
Ex_plot.name = "Exact"

Err_plot = fem.Function(V_plot)
Err_plot.name = "Error"

# Helper to calculate error in V before plotting
error_calc = fem.Function(V) 

# --- 8. TIME LOOP ---
print(f"Starting Verification Loop...")
T_h = fem.Function(V) # High-accuracy solution

with io.XDMFFile(domain.comm, "verification_output.xdmf", "w") as xdmf:
    xdmf.write_mesh(domain)
    
    # Save Initial State
    T_plot.interpolate(T_n)
    Ex_plot.interpolate(u_exact)
    xdmf.write_function(T_plot, t)
    xdmf.write_function(Ex_plot, t)

    for i in range(num_steps):
        t += dt
        
        # A. Update Exact Solution
        exact_sol.t = t
        u_exact.interpolate(exact_sol)
        
        # B. Solve (High Accuracy)
        T_h = problem.solve()
        
        # C. Update Previous Step
        T_n.x.array[:] = T_h.x.array
        
        # --- D. SAVE TO FILE ---
        # 1. Interpolate High-Order results to Low-Order Plotting functions
        T_plot.interpolate(T_h)
        Ex_plot.interpolate(u_exact)
        
        # 2. Calculate Error (Numerical - Exact)
        error_calc.x.array[:] = T_h.x.array - u_exact.x.array
        Err_plot.interpolate(error_calc)
        
        # 3. Write to XDMF
        xdmf.write_function(T_plot, t)
        xdmf.write_function(Ex_plot, t)
        xdmf.write_function(Err_plot, t)

        # E. Print Math Error (The Proof)
        if (i+1) % 5 == 0:
            error_L2 = np.sqrt(domain.comm.allreduce(
                fem.assemble_scalar(fem.form((T_h - u_exact)**2 * ufl.dx)), op=MPI.SUM))
            print(f"Step {i+1}: t={t:.2f}, L2 Error={error_L2:.2e}")

# --- 9. FINAL RESULT ---
print("-" * 40)
print(f"Final L2 Error: {error_L2:.5e}")
if error_L2 < 1e-12:
    print("✅ SUCCESS: The code matches the analytical solution perfectly.")
else:
    print("❌ CHECK: Error is too high.")
print("-" * 40)
