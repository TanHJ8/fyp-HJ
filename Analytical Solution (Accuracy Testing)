import numpy as np
from mpi4py import MPI
from dolfinx import mesh, fem
from dolfinx.fem.petsc import LinearProblem
import ufl

# --- 1. DEFINE THE DOMAIN ---
# 32x32 mesh is sufficient for verification
domain = mesh.create_unit_square(MPI.COMM_WORLD, 32, 32, mesh.CellType.quadrilateral)
V = fem.functionspace(domain, ("Lagrange", 1))

# --- 2. PARAMETERS ---
t = 0
T_final = 1.0
num_steps = 20
dt = T_final / num_steps
rho = 1.0; c = 1.0; k = 0.1 

# --- 3. DEFINE EXACT SOLUTION (The "Benchmark") ---
# We force the code to find this answer: T = 1 + x^2 + y^2 + t
class ExactSolution:
    def __init__(self, t):
        self.t = t
    def __call__(self, x):
        return 1 + x[0]**2 + x[1]**2 + self.t

exact_sol = ExactSolution(t)
u_exact = fem.Function(V)
u_exact.interpolate(exact_sol)

# --- 4. BOUNDARY CONDITIONS ---
# The boundary must match the exact solution
tdim = domain.topology.dim
fdim = tdim - 1
domain.topology.create_connectivity(fdim, tdim)
boundary_facets = mesh.exterior_facet_indices(domain.topology)
boundary_dofs = fem.locate_dofs_topological(V, fdim, boundary_facets)

# We bind the BC to u_exact. We will update u_exact inside the loop.
bc = fem.dirichletbc(u_exact, boundary_dofs)

# --- 5. INITIAL CONDITION ---
# At t=0, the simulation must start with the correct shape
T_n = fem.Function(V)
exact_sol.t = 0
T_n.interpolate(exact_sol)

# --- 6. DEFINE SOURCE TERM 'f' ---
# To force the answer T = 1 + x^2 + y^2 + t, we need a specific source.
# Governing Eq: rho*c*dT/dt - k*Laplacian(T) = f
# Plug in T:    rho*c*(1)   - k*(2+2)        = f
# Result:       f = rho*c - 4k
f_val = (rho * c * 1.0) - (k * 4.0)
f = fem.Constant(domain, f_val)

# --- 7. VARIATIONAL PROBLEM ---
u, v = ufl.TrialFunction(V), ufl.TestFunction(V)

# The "- f * v * ufl.dx" term is crucial. It balances the equation.
F = rho * c * (u - T_n) / dt * v * ufl.dx \
    + k * ufl.dot(ufl.grad(u), ufl.grad(v)) * ufl.dx \
    - f * v * ufl.dx

a = ufl.lhs(F)
L = ufl.rhs(F)

# FIX: Added 'petsc_options_prefix' to solve your TypeError
problem = LinearProblem(a, L, bcs=[bc], 
                        petsc_options={"ksp_type": "preonly", "pc_type": "lu"},
                        petsc_options_prefix="verification_solver")

# --- 8. TIME LOOP & ACCURACY CHECK ---
print(f"Starting Verification Loop (Target Error < 1e-12)...")
T_h = fem.Function(V)

for i in range(num_steps):
    t += dt
    
    # A. Update Exact Solution for the new time (updates BCs automatically)
    exact_sol.t = t
    u_exact.interpolate(exact_sol)
    
    # B. Solve
    T_h = problem.solve()
    
    # C. Update previous step
    T_n.x.array[:] = T_h.x.array

# --- 9. CALCULATE ERROR ---
# We compare the Code Result (T_h) vs Math Result (u_exact)
error_L2 = np.sqrt(domain.comm.allreduce(
    fem.assemble_scalar(fem.form((T_h - u_exact)**2 * ufl.dx)), 
    op=MPI.SUM
))

print("-" * 40)
print(f"Final Time: {t:.2f}")
print(f"L2 Error:   {error_L2:.5e}")  # Should be very small (e.g., 2e-15)
print("-" * 40)

if error_L2 < 1e-12:
    print("✅ ACCURACY CONFIRMED: The code is working perfectly.")
else:
    print("❌ ACCURACY FAILED: Something is wrong.")
